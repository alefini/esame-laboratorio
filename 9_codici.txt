#include "gestione_storia.h"
#include "gestione/gestione_personaggio.h"
#include "gestione/gestione_parole_chiave.h"
#include "analizzatore_lessicale.h"
#include "globali.h"

#include <stdlib.h>

int main(void) {
	inizializzazione_parole_chiave();
	inizializzazione_file();

	printf("Corre l’anno 1492, l’esploratore James Boston è alla ricerca della famosa moneta di Hoysala, antica moneta di origine orientale spedita in lungo e in largo passando anche per le mani del mercante italiano Marco Polo come scritto da testimonianza nella sua opera “Il Milione”. Le ultime informazioni risalenti all’avvistamento di Hoysala portano il nostro James ai piedi del castello di Wrecked, luogo inesplorato da ormai centinaia di anni, insito di pericoli. James decide di farsi coraggio e di avventurarsi all’interno delle mura del castello…\n\n");

	inizializzazione_personaggio(&james);
	descrivere_ambiente(1);
	
	while(get_punti_vita_personaggio(james) > 0 && get_posizione_personaggio(james) != 16) {

		char *input = calloc(20, sizeof(char));
		printf("\nProssima mossa: ");
		fgets(input, 50, stdin);

		analizzare_comando(input);

		eseguire_comando(ident, &james);

		input[0] = '\0';

	}

	return 0;
}

#include <stdlib.h>
#include "../globali.h"

//gestione destinazione
int get_id_destinazione(direzione dir) {
	return dir.id_destinazione;
}

char get_punto_cardinale(direzione dir) {
	return dir.punto_cardinale;
}

void set_id_destinazione(direzione * dir, int dest) {
	dir->id_destinazione = dest;
	return;
}

void set_punto_cardinale(direzione * dir, char pc) {
	dir->punto_cardinale = pc;
}

bool get_apertura_direzione(direzione dir) {
	return dir.apertura;
}

void set_apertura_direzione(direzione * dir, bool apertura) {
	dir->apertura = apertura;
	return;
}

int get_id_chiave_direzione(direzione dir) {
	return dir.id_chiave;
}

void set_id_chiave_direzione(direzione * dir, int chiave) {
	dir->id_chiave = chiave;
	return;
}


//gestione stanza
int get_id_ambiente (ambiente stanza) {
	return stanza.id;
}

void set_id_ambiente (ambiente * stanza, int id) {
	stanza->id = id;
	return;
}

char * get_descrizione_ambiente(ambiente stanza) {
	return stanza.descrizione;
}

void set_descrizione_ambiente(ambiente * stanza, char * desc) {
	stanza->descrizione = malloc(500 * sizeof(char));
	strncpy(stanza->descrizione, desc, 200);
	return;
}

oggetto get_oggetto_ambiente (ambiente stanza, int pos) {
	return stanza.elenco_oggetti[pos];
}

void set_oggetto_ambiente (ambiente * stanza, int pos, oggetto obj) {
	stanza->elenco_oggetti[pos] = obj;
	return;
}

direzione get_direzione_ambiente (ambiente stanza, int pos) {
	return stanza.direzioni_possibili[pos];
}

void set_direzione_ambiente (ambiente * stanza, int pos, direzione dir) {
	stanza->direzioni_possibili[pos] = dir;
	return;
}

//oggetto guardabile -stanza
oggetto_guardabile get_oggetto_guardabile_ambiente(ambiente stanza, int pos) {
	return stanza.looked[pos];
}

void set_oggetto_guardabile_ambiente(ambiente * stanza, int pos, oggetto_guardabile obj_look) {
	stanza->looked[pos] = obj_look;
	return;
}

//contatori
void set_count_obj_ambiente(ambiente * stanza, int number) {
	stanza->count_obj = number;
	return;
}

int get_count_obj_ambiente(ambiente stanza) {
	return stanza.count_obj;
}

void set_count_dir_ambiente(ambiente * stanza, int number) {
	stanza->count_dir = number;
	return;
}

int get_count_dir_ambiente(ambiente stanza) {
	return stanza.count_dir;
}

void set_count_look_ambiente(ambiente * stanza, int number) {
	stanza->count_look = number;
	return;
}

int get_count_look_ambiente(ambiente stanza) {
	return stanza.count_look;
}

#include <stdlib.h>
#include <stdio.h>
#include <time.h> 

#include "../globali.h"
#include "gestione_personaggio.h"
#include "gestione_nemico.h"
#include "gestione_oggetto.h"
#include "../gestione_storia.h"

void attaccare_nemico(nemico * enemy, arma arma_pg)
{
  int punti_attuali = get_punti_vita_nemico(*enemy) - get_danno_arma(arma_pg);
	set_punti_vita_nemico(enemy, punti_attuali);
}

void difendere_nemico(nemico *enemy)
{
	set_durezza_arma(&enemy->weapon.oggetto_speciale.weapon, get_durezza_arma(enemy->weapon.oggetto_speciale.weapon) - 1);
}

void attaccare_personaggio(personaggio *pg, arma arma_enemy)
{
  int punti_attuali = get_punti_vita_personaggio(*pg) - get_danno_arma(arma_enemy);
	set_punti_vita_personaggio(pg, punti_attuali);
}

void difendere_personaggio(personaggio *pg)
{
	set_durezza_arma(&pg->weapon.oggetto_speciale.weapon, get_durezza_arma(pg->weapon.oggetto_speciale.weapon) - 1);
}

void combattimento (personaggio *pg , nemico *enemy)
{
  srand(time(NULL));
  int precisione, esito = 0;
	char risposta[20];
	printf("\nCOMINCIA IL COMBATTIMENTO\n\n");

	arma arma_pg = get_weapon_personaggio(*pg).oggetto_speciale.weapon;
	arma arma_enemy = get_arma_nemico(*enemy).oggetto_speciale.weapon;

  do {

    printf ("Scegli la tua mossa, attacchi o difendi ? : ");
    scanf("%s", risposta);
		printf("\033[0;0H\033[2J");
    
    int casuale = rand()%100;

		if(strcmp(risposta, "attacca") == 0) {

			if(casuale >= 50) {			//nemico attacca
				
				precisione = rand()%100;
				if(precisione >= 25) {

					printf("Riesci a colpire il nemico ma ");

					attaccare_nemico(enemy, arma_pg);

				} else printf("Non riesci a colpire il nemico ma ");

				precisione = rand()%100;
				if(precisione >= 25) {
					printf("il suo colpo va comunque a segno, ferendoti...\n");

					attaccare_personaggio(pg, arma_enemy);

				} else printf("lui non riesce a prenderti!\n"); 
				
			} else {																			 			//nemico difende

				int precisione = rand()%100;	
				if(precisione >= 25) {
					printf("Colpisci il nemico ");

					if(get_durezza_arma(get_arma_nemico(*enemy).oggetto_speciale.weapon) > 0) {

						printf("ma lui riesce a parare il tuo colpo rimandendo illeso...\n");

						difendere_nemico(enemy);

					} else {
						printf("e lo prendi in pieno!\n");

						attaccare_nemico(enemy, arma_pg);
					}
					
				} else printf("Hai mancato il colpo !!!\n");
				
			}

		} else if(strcmp(risposta, "difendi") == 0) {

			if(casuale >= 50) {			//nemico attaccare

				precisione = rand()%100;
				if(precisione >= 25) {

					printf("Il nemico cerca di colpirti ma ");

					if(get_durezza_arma(get_weapon_personaggio(*pg).oggetto_speciale.weapon) > 0) {

						printf("riesci a difenderti !!!\n");
						difendere_personaggio(pg); 

					} else {

						printf("non riesci a difenderti in tempo...\n");
						attaccare_personaggio(pg, arma_enemy);

					}	

				} else printf("Il nemico manca il colpo\n");

			} else {			//nemico difende
				printf("Vi difendete entrambi\n");
			}

		}
    else printf("Comando non riconosciuto\n");

		printf("HP di James: %d, HP del nemico: %d\n", get_punti_vita_personaggio(*pg), get_punti_vita_nemico(*enemy));
		printf("Durezza dell'arma di James: %d, Durezza dell'arma del nemico: %d\n", get_durezza_arma(get_weapon_personaggio(*pg).oggetto_speciale.weapon), get_durezza_arma(get_arma_nemico(*enemy).oggetto_speciale.weapon));

  } while (get_punti_vita_personaggio(*pg) > 0 && get_punti_vita_nemico(*enemy) > 0);

  if (get_punti_vita_personaggio(*pg) <= 0)
  {
    printf("\nSei morto\n");
  }
  else if (get_punti_vita_nemico(*enemy) <= 0)
  { 
    remove_enemy_from_file(get_posizione_personaggio(*pg));
  }

  return;
}

#include "../globali.h"

void set_punti_vita_nemico(nemico * enemy, int hp) {
	enemy->punti_vita = hp;
	return;
}

int get_punti_vita_nemico(nemico enemy) {
	return enemy.punti_vita;
}

void set_arma_nemico(nemico * enemy, oggetto weapon) {
	enemy->weapon = weapon;
	return;
}

oggetto get_arma_nemico(nemico enemy) {
	return enemy.weapon;
}

#include "../globali.h"
#include "gestione_personaggio.h"
#include "gestione_ambiente.h"
#include "../gestione_storia.h"

#include <stdlib.h>
#include <string.h>

int get_id_oggetto(oggetto obj) {
	return obj.ID;
}

char * get_nome_oggetto(oggetto obj) {
	char *support = calloc(10, sizeof(char));
	strcpy(support, obj.nome);
	return support;
}

bool get_afferrabile_oggetto(oggetto obj) {
	return obj.afferrabile;
}

tipo_oggetto get_tipo_oggetto(oggetto obj) {
	return obj.tipo;
}

void set_id_oggetto(oggetto * obj, int number) {
	obj->ID = number;
	return;
}

void set_nome_oggetto(oggetto *obj, char* nome) {
	strcpy(obj->nome, nome);
	return;
}

void set_afferrabile_oggetto(oggetto *obj, bool aff) {
	obj->afferrabile = aff;
	return;
}

void set_tipo_oggetto(oggetto *obj, char type) {
	obj->tipo = type;
}

void set_punti_vita_cibo(cibo * food, int hp) {
	food->punti_vita = hp;
}

int get_punti_vita_cibo(cibo food) {
	return food.punti_vita;
}

void set_danno_arma(arma * weapon, int danno) {
	weapon->danno = danno;
	return;
}

void set_durezza_arma(arma * weapon, int durezza) {
	weapon->durezza = durezza;
	return;
}

int get_danno_arma(arma weapon)
{
  return weapon.danno;
}

int get_durezza_arma(arma weapon)
{
  return weapon.durezza;
}

char * get_nome_oggetto_guardabile(oggetto_guardabile obj_look) {
	char *support = calloc(10, sizeof(char));
	strcpy(support, obj_look.nome);
	return support;
}

void set_nome_oggetto_guardabile(oggetto_guardabile * obj_look, char * element) {
	strcpy(obj_look->nome, element);
	return;
}

void set_number_id_oggetto_guardabile(oggetto_guardabile * obj_look, int number) {
	obj_look->number_id = number;
}

int get_number_id_oggetto_guardabile(oggetto_guardabile obj_look) {
	return obj_look.number_id;
}

int get_id_oggetto_guardabile(oggetto_guardabile obj_look, int pos) {
	return obj_look.elenco_id[pos];
}

void set_id_oggetto_guardabile(oggetto_guardabile * obj_look, int pos, int element) {
	obj_look->elenco_id[pos] = element;
	return;
}

int impugnare_arma(personaggio *pg, char * nome_arma) {

  int i = 0, esito = 0;
  bool trovato = false;

	oggetto empty;
	set_id_oggetto(&empty, 0);
	set_nome_oggetto(&empty, "vuoto");
	set_afferrabile_oggetto(&empty, false);

  while (get_id_oggetto(get_slot_inventario_personaggio(*pg, i)) != 0 && trovato== false) {
			
    if (strcmp(get_nome_oggetto(get_slot_inventario_personaggio(*pg, i)), nome_arma) == 0) {

			if(get_tipo_oggetto(get_slot_inventario_personaggio(*pg, i)) == 'a') {
				set_weapon_personaggio(pg, get_slot_inventario_personaggio(*pg, i));
				set_slot_inventario_personaggio(pg, i, empty);
			} else esito = -10;
			
      trovato = true;
    }
    i = i + 1;
  }
  if (trovato == false) {
		esito = -6;
	}
  
	return esito;
}

int mangiare_cibo(personaggio *pg, char * nome_cibo)
{
  int hp = get_punti_vita_personaggio(*pg), esito = 0;
	bool trovato = false;

	oggetto empty;
	set_id_oggetto(&empty, 0);
	set_nome_oggetto(&empty, "vuoto");
	set_afferrabile_oggetto(&empty, false);

  if (hp == 100)
  {
    esito = -4;
  }
  else
  {
		int count = 0;
		while(count < MAX_SLOTS && trovato == false) {

			if(strcmp(nome_cibo, get_nome_oggetto(get_slot_inventario_personaggio(*pg, count))) == 0) {

				if(get_tipo_oggetto(get_slot_inventario_personaggio(*pg, count)) == food) {

					set_punti_vita_personaggio(pg, get_punti_vita_cibo(get_slot_inventario_personaggio(*pg, count).oggetto_speciale.food) + get_punti_vita_personaggio(*pg));
					
					set_slot_inventario_personaggio(pg, count, empty);

					if(get_punti_vita_personaggio(*pg) > MAX_HEALTH) {
						set_punti_vita_personaggio(pg, MAX_HEALTH);
					}

				} else {
					esito = -5;
				}

				trovato = true;
			} 

			count = count + 1;
		}

		if(trovato == false) {
			esito = -6;
		}

  }

	return esito;
}

//gestione oggetti apribili
void set_apertura_apribile(oggetto_apribile *obj, bool apertura)
{
  obj->apertura = apertura;
  return;
}

bool get_apertura_apribile(oggetto_apribile obj)
{
  return obj.apertura;
}

void set_id_chiave_da_usare(oggetto_apribile *obj, int id_key)
{
  obj->id_chiave = id_key;
  return;
}

int get_id_chiave_da_usare(oggetto_apribile obj) {
	return obj.id_chiave;
}

int aprire_oggetto(personaggio *pg, char * name_obj) {
  bool trovato = false;
  int i = 0, esito = 0;

	oggetto empty;
	set_id_oggetto(&empty, 0);
	set_nome_oggetto(&empty, "vuoto");
	set_afferrabile_oggetto(&empty, false);

	oggetto temp;

	while(i < get_count_obj_ambiente(stanza_attuale) && trovato == false) {

		if(strcmp(get_nome_oggetto(get_oggetto_ambiente(stanza_attuale, i)), name_obj) == 0) {
			temp = get_oggetto_ambiente(stanza_attuale, i);

			if(get_tipo_oggetto(temp) == key) {

				if(get_apertura_apribile(temp.oggetto_speciale.key) == false) {

					int j = 0;
					while(j< MAX_SLOTS && trovato == false) {

						if(get_id_oggetto(get_slot_inventario_personaggio(*pg, j)) == get_id_chiave_da_usare(temp.oggetto_speciale.key)) {
							set_apertura_apribile(&temp.oggetto_speciale.key, true);		//imposto oggetto Aperto
							set_slot_inventario_personaggio(pg, j, empty);							//elimino la chiave
							trovato = true;
						}

						j = j + 1;
					}

				} else esito = -13; 		//oggetto già aperto

				if(trovato == false) {
					esito = -12;					//oggetto non trovato
				}

			} else {
				esito = -14;						//oggetto non di tipo key
			}

		}

		i = i + 1;
	}

  return esito;
}

int aprire_porta(ambiente * stanza, personaggio * pg, char point) {
	int esito = 0, i = 0;
	bool trovato_1 = false, trovato_2 = false;		//trovato_1 stanza trovato_2 chiave

	while(i < get_count_dir_ambiente(*stanza) && trovato_1 == false) {

		direzione dir = get_direzione_ambiente(*stanza, i);

		if(get_punto_cardinale(dir) == point) {
			trovato_1 = true;

			if(get_apertura_direzione(dir) == false) {

				if(get_id_chiave_direzione(dir) == 0) {
					set_apertura_direzione(&stanza->direzioni_possibili[i], true);
					open_door_from_file(dir, get_posizione_personaggio(*pg));
					trovato_2 = true;
				} else {

					int j = 0;
					while(get_id_oggetto(get_slot_inventario_personaggio(*pg, j)) != 0 && trovato_2 == false) {

						if(get_id_oggetto(get_slot_inventario_personaggio(*pg, j)) == get_id_chiave_direzione(dir)) {
							set_apertura_direzione(&stanza->direzioni_possibili[i], true);
							open_door_from_file(dir, get_posizione_personaggio(*pg));
							trovato_2 = true;
						}

						j = j + 1;
					}

				}			

			} else esito = -13;			//oggetto già aperto

		}

		i = i + 1;

	}

	if(esito == 0) {
		if(trovato_1 == false) {
			esito = -3;
		} else if(trovato_2 == false) {
			esito = -12;
		}
	}

	return esito;
}  

#include <stdlib.h>

#include "../globali.h"
#include "../analizzatore_lessicale.h"
#include "gestione_tabella_simboli.h"

void inizializzazione_parole_chiave() {

	char pathname[20] = "parole_chiave.txt";
	FILE *fp;
	int count_1 = 0;
	char *support = malloc(10 * sizeof(char));

	if((fp = fopen(pathname, "r")) != NULL) {

		while(!feof(fp)) {
			fgets(support, 100, fp);
			int check = 0, count = 0;

			while(count < strlen(support)) {

				char * token = malloc(10 * sizeof(char));
				token = scan(support, count);

				if(check == 0) {
					
					set_parola_tab_simboli(keywords, count_1, token);
					
					check = 1;

				} else if (check == 1) {

					set_simbolo_tab_simboli(keywords, count_1, token);
					set_number_tab_simboli(keywords, get_number_tab_simboli(keywords)+1);

					count_1 = count_1 + 1;
					check = 0;
				}

				int lenght = 0 + strlen(token);
				*token = '\0';
				count = count + 1 + lenght;
			}

			*support = '\0';
		}

	} else printf("Impossibile aprire il file");

	return;
}

#include "../globali.h"
#include "gestione_oggetto.h"
#include "gestione_ambiente.h"
#include "../gestione_storia.h"

void set_punti_vita_personaggio(personaggio *pg, int hp) {
	pg->punti_vita = hp;
}

void set_slot_inventario_personaggio(personaggio *pg, int pos, oggetto obj) {
	pg->inventario[pos] = obj;
}

void set_weapon_personaggio(personaggio *pg, oggetto weapon) {
	pg->weapon = weapon;
}

int get_punti_vita_personaggio(personaggio pg) {
	return pg.punti_vita;
}

oggetto get_slot_inventario_personaggio(personaggio pg, int pos) {
	return pg.inventario[pos];
}

oggetto get_weapon_personaggio(personaggio pg) {
	return pg.weapon;
}

void set_posizione_personaggio(personaggio * pg, int element) {
	pg->posizione = element;
}

int get_posizione_personaggio(personaggio pg) {
	return pg.posizione;
}

void inizializzazione_inventario(personaggio *pg) {
	int count = 0;

	oggetto empty;
	set_id_oggetto(&empty, 0);
	set_nome_oggetto(&empty, "vuoto");
	set_afferrabile_oggetto(&empty, false);

	while(count < MAX_SLOTS) {
		set_slot_inventario_personaggio(pg, count, empty);
		count = count + 1;
	} 

	return;
}

void inizializzazione_personaggio(personaggio *pg) {
	set_posizione_personaggio(pg, 1);
	set_punti_vita_personaggio(pg, MAX_HEALTH);
	inizializzazione_inventario(pg);
}

int controllare_inventario(personaggio pg) {
	int count = 0, pos = -1;

	while(count < MAX_SLOTS && pos == -1) {
		
		if(strcmp(get_nome_oggetto(get_slot_inventario_personaggio(pg, count)), "vuoto") == 0) {
			pos = count;
		}

		count = count + 1;
	}

	return pos;
}

void stampare_inventario(personaggio pg)
{
  int i=0;
  while(i< MAX_SLOTS)
  {
    if(strcmp(get_nome_oggetto(get_slot_inventario_personaggio(pg, i)), "vuoto")!= 0)
    {
      printf("%s ", get_nome_oggetto(get_slot_inventario_personaggio(pg, i)));
    }
    i = i + 1;
  }
  printf("\n");

  return;
}

void ordinare_inventario(personaggio *pg) {

	oggetto empty;
	set_id_oggetto(&empty, 0);
  set_nome_oggetto(&empty, "vuoto");
  set_afferrabile_oggetto(&empty, false);
	
	int count = 0;
	while(count < MAX_SLOTS) {

		if(get_id_oggetto(get_slot_inventario_personaggio(*pg, count)) == 0) {

			int count_1 = count + 1;
			while(count_1 < MAX_SLOTS) {

				if(get_id_oggetto(get_slot_inventario_personaggio(*pg, count_1)) != 0) {
					set_slot_inventario_personaggio(pg, count, get_slot_inventario_personaggio(*pg, count_1));
					set_slot_inventario_personaggio(pg, count_1, empty);
					count_1 = MAX_SLOTS;
				}

				count_1 = count_1 + 1;
			}

		}

		count = count + 1;
	}
}

int prendere_oggetto(personaggio *pg, char * name_object) {
	
	oggetto object;
	int count = 0, pos, esito = 0;
	bool afferrabile = false, trovato = false;

	direzione dir;
	set_id_destinazione(&dir, 16);
	set_punto_cardinale(&dir, 'b');

	while(count < get_count_obj_ambiente(stanza_attuale) && trovato == false) {

		if(strcmp(name_object, get_nome_oggetto(get_oggetto_ambiente(stanza_attuale, count))) == 0) {
			object = get_oggetto_ambiente(stanza_attuale, count);
			afferrabile = get_afferrabile_oggetto(object);
      trovato = true;
		}

		count = count + 1;
	}

  pos = controllare_inventario(*pg);

  if (pos != -1 && afferrabile != false)
  {
    set_slot_inventario_personaggio(pg, pos, object);
		remove_object_from_file(get_id_oggetto(object));

		if(strcmp(name_object, "libro") == 0 && get_posizione_personaggio(*pg) == 15) {
			open_door_from_file(dir, get_posizione_personaggio(*pg));
			printf("\nLa libreria comincia a vibrare ed a muoversi verso ovest, rivelando un passaggio segreto che va verso il basso\n");
		}

		descrivere_ambiente(get_posizione_personaggio(*pg));
  }
  else if (pos == -1)
  {
    esito = -8;
  }
  else esito = -7;

  return esito;
}

int lasciare_oggetto(personaggio *pg, char *nome_oggetto) {
  int i = 0, esito = 0;
  bool trovato = false;

	oggetto empty;
	set_id_oggetto(&empty, 0);
  set_nome_oggetto(&empty, "vuoto");
  set_afferrabile_oggetto(&empty, false);
	
  while (i < MAX_SLOTS && trovato == false) {

    if (strcmp(get_nome_oggetto(get_slot_inventario_personaggio(*pg, i)), nome_oggetto) == 0)
    {
			insert_object_into_file(get_slot_inventario_personaggio(*pg, i), get_posizione_personaggio(*pg));
			descrivere_ambiente(get_posizione_personaggio(*pg));
      set_slot_inventario_personaggio(pg, i, empty);
			ordinare_inventario(pg);
      trovato = true;
    }

    i = i + 1;
  }
  if (trovato == false)
  {
    esito = -6;
  }

  return esito;
}

int muovere_personaggio(personaggio * pg, char dir) {

	int	count = 0, esito = -3;
	while (count < get_count_dir_ambiente(stanza_attuale)) {
		direzione temp = get_direzione_ambiente(stanza_attuale, count);

		if(get_punto_cardinale(temp) == dir) {

			if(get_apertura_direzione(temp)) {
				esito = 0;
				set_posizione_personaggio(pg, get_id_destinazione(temp));
			} else esito = -11;
			
		}

		count = count + 1;
	}

	if(esito == 0) {
		descrivere_ambiente(get_posizione_personaggio(*pg));
	}

	return esito;
}

int guardare_oggetto(ambiente stanza, char * nome_obj) {
	int esito = -7, count = 0;

	if(get_count_look_ambiente(stanza) > 0) {
			
		while(count < get_count_look_ambiente(stanza)) {

			if(strcmp(nome_obj, get_nome_oggetto_guardabile(get_oggetto_guardabile_ambiente(stanza, count))) == 0) {

				esito = 0;
				printf("Hai trovato: ");
				int count_1 = 0;
				while(count_1 < get_number_id_oggetto_guardabile(get_oggetto_guardabile_ambiente(stanza, count))) {

					int id_oggetto = get_id_oggetto_guardabile(&stanza.looked[count], count_1);

					int count_2 = 0;
					while(count_2 < get_count_obj_ambiente(stanza)) {

						if(id_oggetto == get_id_oggetto(get_oggetto_ambiente(stanza, count_2))) {  
							printf("%s ", get_nome_oggetto(get_oggetto_ambiente(stanza, count_2)));
						}

						count_2 = count_2 + 1;
					}

					count_1 = count_1 + 1;
				}
				printf("\n");
				
			}

			count = count + 1;
		}

	} else esito = -9; 


	return esito;
}

#include "../globali.h"

char * get_parola_tab_simboli(tabella_simboli * tab, int pos) {
	return tab[pos].parola;
}

void set_parola_tab_simboli(tabella_simboli * tab, int pos, char * element) {
	strcpy(tab[pos].parola, element);
	return;
}

char * get_simbolo_tab_simboli(tabella_simboli * tab, int pos) {
	return tab[pos].simbolo;
}

void set_simbolo_tab_simboli(tabella_simboli * tab, int pos, char * element) {
	strcpy(tab[pos].simbolo, element);
	return;
}

int get_number_tab_simboli(tabella_simboli * tab) {
	return tab->number;
}

void set_number_tab_simboli(tabella_simboli * tab, int element) {
	tab->number = element;
	return;
}

void stampa_tabella_simboli (tabella_simboli * tab) {
	int count = 0;
	
	while(count < get_number_tab_simboli(tab)) {
		printf("parola: %s, simbolo: %s\n", get_parola_tab_simboli(tab, count), get_simbolo_tab_simboli(tab, count));
		count = count + 1;
	}

}

#include <stdlib.h>

#include "globali.h" 
#include "gestione/gestione_tabella_simboli.h"
#include "gestione/gestione_personaggio.h"
#include "gestione/gestione_oggetto.h"
#include "gestione_storia.h"
#include "salvataggio.h"

void gestione_errore (int result);

char * scan(char* input, int offset) {
	
	char *token = calloc(10, sizeof(char));	//inizializza lo spazio di memoria dinamica

	*token = '\0';
	int count = 0;

	while(input[offset] != ' ' && input[offset] != '\n' && offset < strlen(input)) {
		token[count] = input[offset];
		count = count + 1;
		offset = offset + 1;
	}

	return token;
}

char * check_parola_chiave (char * token) {
	
	char * symbol = malloc(10 * sizeof(char));
	strcpy(symbol, "EMP");

	int count = 0;
	while (count < get_number_tab_simboli(keywords)) {

		if(strcmp(token, get_parola_tab_simboli(keywords, count)) == 0) {
			strcpy(symbol, get_simbolo_tab_simboli(keywords, count));
		}

		count = count + 1;	
	}

	return symbol;
}

void analizzare_comando(char * input) {

	int count = 0;
	set_number_tab_simboli(ident, 0);
	char *token = malloc(20 * sizeof(char));

	token = strtok(input, " \n");

	while(token) {

		int count_1 = 0, stato_corrente = 0, stato_pozza = 2;
		
		while(count_1 < strlen(token) && stato_corrente != stato_pozza) {

			if(token[count_1] >= 'a' && token[count_1] <= 'z') {
				if(stato_corrente == 0 || stato_corrente == 1) {
					stato_corrente = 1;
				}
			} else {
				stato_corrente = stato_pozza;
			}

			count_1 = count_1 + 1;
		}

		if(stato_corrente != stato_pozza) {		//parola corretta
			
			set_parola_tab_simboli(ident, get_number_tab_simboli(ident), token);

			if(strcmp(check_parola_chiave(token), "EMP") != 0) {
				
				set_simbolo_tab_simboli(ident, get_number_tab_simboli(ident), check_parola_chiave(token));

			} else {

				set_simbolo_tab_simboli(ident, get_number_tab_simboli(ident), "OBJ");

			}

		} else {											//parola scorretta - con dentro numeri

			set_parola_tab_simboli(ident, get_number_tab_simboli(ident), "0");
			set_simbolo_tab_simboli(ident, get_number_tab_simboli(ident), "0");

		}

		set_number_tab_simboli(ident, get_number_tab_simboli(ident) + 1);

		token = strtok(NULL, " \n");
	}

	return;
}

void eseguire_comando (tabella_simboli * tab, personaggio * pg) {
	int esito = 0;

	if(strcmp(get_simbolo_tab_simboli(tab, 0),  "TKE") == 0) { 								//prendi
		esito = prendere_oggetto(pg, get_parola_tab_simboli(tab, 1));

		printf("Oggetto preso\n");

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "LVE") == 0) {					//lascia
		esito = lasciare_oggetto(pg, get_parola_tab_simboli(tab, 1));

		if(esito == 0) {
			printf("Oggetto lasciato\n");
		}

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "VAI") == 0) {					//vai

		char direction;
		if(strcmp(get_parola_tab_simboli(tab, 1), "nord") == 0) {
			direction = 'n';
		} else if(strcmp(get_parola_tab_simboli(tab, 1), "est") == 0) {
			direction = 'e';
		} else if(strcmp(get_parola_tab_simboli(tab, 1), "sud") == 0) {
			direction = 's';
		} else if(strcmp(get_parola_tab_simboli(tab, 1), "ovest") == 0) {
			direction = 'o';
		} else if(strcmp(get_parola_tab_simboli(tab, 1), "su") == 0) { 
			direction = 'a';
		} else if(strcmp(get_parola_tab_simboli(tab, 1), "giu") == 0) {
			direction = 'b';
		} else {
			esito = -2;
		}

		if(esito != -2) {
			esito = muovere_personaggio(pg, direction);
		} 

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "LOK") == 0) {					//guarda

		if(strcmp(get_parola_tab_simboli(tab, 1),  "arma") == 0) {
			
			if(get_id_oggetto(get_weapon_personaggio(*pg))) {
				printf("Stai impugnando %s, danno: %d, durezza:%d\n", get_nome_oggetto(get_weapon_personaggio(*pg)), get_danno_arma(get_weapon_personaggio(*pg).oggetto_speciale.weapon), get_durezza_arma(get_weapon_personaggio(*pg).oggetto_speciale.weapon));
			} else esito = -10;

		} else if(strcmp(get_parola_tab_simboli(tab, 1),  "uomo") == 0 && get_posizione_personaggio(*pg) == 14) {
			 indovino_indovinello();
		} else esito = guardare_oggetto(stanza_attuale, get_parola_tab_simboli(tab, 1));

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "OPN") == 0) {					//apri

		if(strcmp(get_parola_tab_simboli(tab, 1), "porta") == 0) {

			char direction;
			if(strcmp(get_parola_tab_simboli(tab, 2), "nord") == 0) {
				direction = 'n';
			} else if(strcmp(get_parola_tab_simboli(tab, 2), "est") == 0) {
				direction = 'e';
			} else if(strcmp(get_parola_tab_simboli(tab, 2), "sud") == 0) {
				direction = 's';
			} else if(strcmp(get_parola_tab_simboli(tab, 2), "ovest") == 0) {
				direction = 'o';
			} else esito = -2;

			if(esito != -2) {
				esito = aprire_porta(&stanza_attuale, pg, direction);
			}

			if(esito == 0) {
				printf("Porta aperta\n");
			}

		} else {
			esito = aprire_oggetto(pg, get_parola_tab_simboli(tab, 1));

			if(esito == 0) {
				printf("Oggetto aperto\n");
			}
		}

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "EAT") == 0) {					//mangia
		esito = mangiare_cibo(pg,  get_parola_tab_simboli(tab, 1));

		if(esito == 0) {
			printf("Hai mangiato\n");
		}

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "SLT") == 0) {					//salute

		printf("Hai %d punti vita\n", get_punti_vita_personaggio(*pg));

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "INV") == 0) {					//inventario
		printf("Inventario:\n");
		stampare_inventario(*pg);

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "HEL") == 0) {					//aiuto

		printf("\nCiao piccolo giocatore, ti serve aiuto?\n\nEccoti alcuni comandi di base:\n\n-Digita il comando 'vai (nord, sud, est, ovest, su, giù)' per spostarti nella direzione desiderata.\n\n-Digita il comando 'guarda (nome oggetto da guardare)' per osservare meglio l'oggetto desiderato.\n\n-Digita il comando 'prendi (nome oggetto, spada ad esempio)' per inserire l'oggetto nell'inventario, inoltre per utilizzare le armi bisogna digitare il comando 'impugna (nome oggetto, spada ad esempio)' ovviamente l'oggetto deve essere presente nel tuo inventario.\n\n-Digita il comando 'lascia (nome oggetto da lasciare)' per liberare l'inventario dall'oggetto selezionato.\n\nDurante un combattimento i comandi disponibili sono: attacca, difendi per eseguire l'azione desiderata.\n\n-Digita il comando 'mangia' (nome cibo, mela ad esempio) per recuperare alcuni HP.\n\nDigita il comando 'salute o s' per vedere i tuoi HP rimanenti.\n\n-Digita il comando 'apri porta + (direzione)' per aprire una porta chiusa.\n\n-Digita il comando 'inventario o inv' per visualizzare tutti gli oggetti presenti nell'inventario.\n\n-Digita il comando 'salva' per salvare la partita e 'carica' per caricare l'ultimo salvataggio.\n\n-Digita il comando 'aiuto o h' per visualizzare la lista di tutti i comandi disponibili.\n");

	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "SLV") == 0) {
		salvataggio_partita(stanza_attuale, *pg);
		printf("Salvataggio effettuato\n");
	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "LOA") == 0) {
		caricare_partita(pg);
		printf("Partita caricata\n");
	} else if(strcmp(get_simbolo_tab_simboli(tab, 0),  "IMP") == 0) {
		esito = impugnare_arma(pg, get_parola_tab_simboli(tab, 1));
	} else {
		esito = -1;
	} 

	gestione_errore(esito);

	return;
}

void gestione_errore (int result) {

	if(result == -1) {
		printf("Non ho capito\n");
	} else if(result == -2) {
		printf("Non ho capito la direzione\n");
	} else if(result == -3) {
		printf("Direzione non consentita\n");
	} else if(result == -4) {
		printf("Punti vita massimi\n");
	} else if(result == -5) {
		printf("Non penso che si possa mangiare...\n");
	} else if(result == -6) {
			printf("Oggetto non presente in inventario\n");
	} else if(result == -7) {
		printf("Non vedi nulla del genere\n");
	} else if(result == -8) {
		printf("Inventario pieno\n");
	} else if(result == -9) {
		printf("Non trovi nulla di interessante\n");
	} else if(result == -10) {
		printf("non stai impugnando nulla\n");
	} else if(result == -11) {
		printf("La porta è chiusa\n");
	} else if(result == -12) {
		printf("Non hai la chiave giusta\n");
	} else if(result == -13) {
		printf("È già aperto\n");
	}

  return;
  
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include "globali.h"
#include "analizzatore_lessicale.h"
#include "gestione/gestione_oggetto.h"
#include "gestione/gestione_ambiente.h"
#include "gestione/gestione_nemico.h"
#include "gestione/gestione_combattimento.h"
#include "gestione_storia.h"

// ^id_stanza
// *OGGETTI
// %direzioni

void inizializzazione_oggetti_ambienti();

void descrivere_ambiente(int room_number) {

	char pathname[20] = "storia.txt", prelievo[MAX_CARATT];
	FILE *file_storia;
	bool trovato = false;
	nemico enemy;
	
	if((file_storia = fopen(pathname, "r")) != NULL) {
		rewind(file_storia);

		while(!feof(file_storia) && trovato == false) {

			char *token = malloc(20 * sizeof(char));

			fgets(prelievo, MAX_CARATT, file_storia);

			if(prelievo[0] == '^') {
				token = scan(prelievo, 1);

				if(convert_sequence_char_to_int(token) == room_number) {
					set_id_ambiente(&stanza_attuale, room_number);
					trovato = true;
				}

				*token = '\0';
			}

			if(trovato == true) {

				inizializzazione_oggetti_ambienti();
				set_count_obj_ambiente(&stanza_attuale, 0);
				set_count_dir_ambiente(&stanza_attuale, 0);
				set_count_look_ambiente(&stanza_attuale, 0);

				//printf("\033[0;0H\033[2J");

				while(prelievo[0] != '_') {

					fgets(prelievo, MAX_CARATT, file_storia);

					if(prelievo[0] != '/' && prelievo[0] != '&' && prelievo[0] != '$' && prelievo[0] != '*' && prelievo[0] != '%' && prelievo[0] != '_') {

						set_descrizione_ambiente(&stanza_attuale, prelievo);
						printf("%s", prelievo);
					
					} else if(prelievo[0] == '&') {							//nemico

						int count = 1;
						bool hp_flag = false, danno_flag = false, durezza_flag = false;
						oggetto wpn_enemy;
						while(prelievo[count]) {
							token = scan(prelievo, count);
							int number = convert_sequence_char_to_int(token);

							if(hp_flag == false) {
								set_punti_vita_nemico(&enemy, number);
								hp_flag = true;
							} else if(get_punti_vita_nemico(enemy) > 0) {

								if(danno_flag == false) {
									set_danno_arma(&wpn_enemy.oggetto_speciale.weapon, number);
									danno_flag = true;
								} else if(durezza_flag == false) {
									set_durezza_arma(&wpn_enemy.oggetto_speciale.weapon, number);
									durezza_flag = true;
								}

								if(danno_flag == true && durezza_flag == true) {
									set_arma_nemico(&enemy, wpn_enemy);

									fgets(prelievo, MAX_CARATT, file_storia);

									if(prelievo[0] == '$') {
										printf("%s", prelievo);
										combattimento(&james, &enemy);
									}
									
								}

							}

							int lenght = 0 + strlen(token);
							count = count + 1 + lenght;
						}

					} else if(prelievo[0] == '/') {							//guarda
						oggetto_guardabile temp;
						int count = 1;
						set_number_id_oggetto_guardabile(&temp, 0);
						
						bool nome_flag = false;

						while(prelievo[count]) {
							token = scan(prelievo, count);

							if(nome_flag == false) {
								set_nome_oggetto_guardabile(&temp, token);
								nome_flag = true;	
							} else {
								set_id_oggetto_guardabile(&temp, get_number_id_oggetto_guardabile(temp), convert_sequence_char_to_int(token));
								set_number_id_oggetto_guardabile(&temp, get_number_id_oggetto_guardabile(temp) + 1);
							}

							int lenght = 0 + strlen(token);
							count = count + 1 + lenght;
						}

						set_oggetto_guardabile_ambiente(&stanza_attuale, get_count_look_ambiente(stanza_attuale), temp);
						set_count_look_ambiente(&stanza_attuale, get_count_look_ambiente(stanza_attuale) + 1);

					} else if(prelievo[0] == '*') {							//oggetto
						bool id_flag = false, nome_flag = false, aff_flag = false, tipo_flag = false, par1_flag = false, par2_flag = false;
						oggetto temp;
						int count = 1;

						while(prelievo[count]) {
							token = scan(prelievo, count);

							if(id_flag == false) {

								set_id_oggetto(&temp, convert_sequence_char_to_int(token));
								id_flag = true; 

							} else if(nome_flag == false) {
								
								set_nome_oggetto(&temp, token);
								nome_flag = true;

							} else if(aff_flag == false) {

								if(strcmp(token, "true") == 0) {
									set_afferrabile_oggetto(&temp, true);
								} else {
									set_afferrabile_oggetto(&temp, false);
								}

								aff_flag = true;
							} else if(tipo_flag == false) {

								if(strcmp(token, "a") == 0) {
									set_tipo_oggetto(&temp, weapon);
								} else if(strcmp(token, "c") == 0) {
									set_tipo_oggetto(&temp, food);
								} else if(strcmp(token, "k") == 0) {
									set_tipo_oggetto(&temp, key);
								} 

								tipo_flag = true;
							} else if(par1_flag == false) {
								
								if(get_tipo_oggetto(temp) == weapon) {

									set_danno_arma(&temp.oggetto_speciale.weapon, convert_sequence_char_to_int(token));

								} else if(get_tipo_oggetto(temp) == food) {

									set_punti_vita_cibo(&temp.oggetto_speciale.food, convert_sequence_char_to_int(token));

								} else if(get_tipo_oggetto(temp) == key) {
								
									if(strcmp(token, "true") == 0) {
										set_apertura_apribile(&temp.oggetto_speciale.key, true);
									} else if(strcmp(token, "false") == 0) {
										set_apertura_apribile(&temp.oggetto_speciale.key, false);
									}
									
								}
							
								par1_flag = true;
							}	else if(par2_flag == false) {

								if(get_tipo_oggetto(temp) == weapon) {
									set_durezza_arma(&temp.oggetto_speciale.weapon, convert_sequence_char_to_int(token));
								} else if(get_tipo_oggetto(temp) == key) {
									set_id_chiave_da_usare(&temp.oggetto_speciale.key, convert_sequence_char_to_int(token));
								}

								par2_flag = true;
							}

							int lenght = 0 + strlen(token);
							*token = '\0';
							count = count + 1 + lenght;
						}

						set_oggetto_ambiente(&stanza_attuale, get_count_obj_ambiente(stanza_attuale), temp);
						set_count_obj_ambiente(&stanza_attuale, get_count_obj_ambiente(stanza_attuale) + 1);
						set_tipo_oggetto(&temp, 'z');

					} else if(prelievo[0] == '%') {					//direzioni possibili
						bool id_flag = false, dir_flag = false, apertura_flag = false, id_chiave_flag = false;
						int count = 1;
						direzione temp;

						while(prelievo[count]) {
							token = scan(prelievo, count);

							if(id_flag == false) {
								set_id_destinazione(&temp, convert_sequence_char_to_int(token));
								id_flag = true;
							} else if(dir_flag == false) {
								set_punto_cardinale(&temp, *token);
								dir_flag = true;
							} else if(apertura_flag == false) {

								if(strcmp(token, "true") == 0) {
									set_apertura_direzione(&temp, true);
								} else if(strcmp(token, "false") == 0){
									set_apertura_direzione(&temp, false);
								}

								apertura_flag = true;
							} else if(id_chiave_flag == false) {
								set_id_chiave_direzione(&temp, convert_sequence_char_to_int(token));
								id_chiave_flag = true;
							}

							int lenght = 0 + strlen(token);
							*token = '\0';
							count = count + 1 + lenght;
						}

						set_direzione_ambiente(&stanza_attuale, get_count_dir_ambiente(stanza_attuale), temp);
						set_count_dir_ambiente(&stanza_attuale, get_count_dir_ambiente(stanza_attuale) + 1);
					}

					*token = '\0';
				}

			}

			free(token);
		}
		
	} else printf("Impossibile aprire il file");

	fclose(file_storia);
}

void inizializzazione_oggetti_ambienti() {

	oggetto empty;
	set_id_oggetto(&empty, 0);
	set_nome_oggetto(&empty, "empty");
	set_afferrabile_oggetto(&empty, false);

	int count = 0;
	while(count <= MAX_SLOTS) {
		set_oggetto_ambiente(&stanza_attuale, count, empty);
		count = count + 1;
	}

	return;
}

int convert_sequence_char_to_int(char *sequence) {
	int count = strlen(sequence)-1;
	int number = 0, moltiplicator = 1;

	while(count >= 0) {
		number = ((sequence[count] - '0') * moltiplicator) + number;

		moltiplicator = moltiplicator * 10;
		count = count - 1;
	}

	return number;
}

void inizializzazione_file() {
	char pathname_write[30] = "storia.txt";
	FILE *file_write;
	char pathname_read[30] = "storia_originale.txt";
	FILE *file_read;

	char prelievo[MAX_CARATT];

	if((file_read = fopen(pathname_read, "r")) != NULL && (file_write = fopen(pathname_write, "w")) != NULL) {

		while(!feof(file_read)) {

			fgets(prelievo, MAX_CARATT, file_read);
	
			fprintf(file_write, "%s", prelievo);

		}
	}

	fclose(file_read);
	fclose(file_write);
}

void remove_object_from_file(int id_object) {
	char pathname_write[30] = "storia_support.txt";
	FILE *file_write;
	char pathname_read[30] = "storia.txt";
	FILE *file_read;

	char prelievo[MAX_CARATT];
	char *token = calloc(10, sizeof(char));

	if((file_read = fopen(pathname_read, "r")) != NULL && (file_write = fopen(pathname_write, "w")) != NULL) {

		while(!feof(file_read)) {

			fgets(prelievo, MAX_CARATT, file_read);

			if(prelievo[0] == '*') {
				token = scan(prelievo, 1);
				int number = convert_sequence_char_to_int(token);

				if(number != id_object) {
					fprintf(file_write, "%s", prelievo);
				}

				*token = '\0';

			} else fprintf(file_write, "%s", prelievo);
	
		}


	} else printf("Impossibile aprire il file");

	fclose(file_read);
	fclose(file_write);

	remove(pathname_read);
	rename(pathname_write, pathname_read);
}

void insert_object_into_file(oggetto obj, int id_number) {

	char pathname_storia[30] = "storia.txt";
	FILE *file_storia;
	char pathname_support[30] = "support_storia.txt";
	FILE *file_support;
	char support[MAX_CARATT];
	char *token = calloc(10, sizeof(char));

	if((file_storia = fopen(pathname_storia, "r")) != NULL && (file_support = fopen(pathname_support, "w")) != NULL) {

		while(!feof(file_storia)) {

			fgets(support, MAX_CARATT, file_storia);
			
			if(support[0] == '^') {
				token = scan(support, 1);
				
				if(convert_sequence_char_to_int(token) == id_number) {
					
					while (support[0] != '*' && support[0] != '%') {
						fprintf(file_support, "%s", support);
						fgets(support, MAX_CARATT, file_storia);
					}
					
					fprintf(file_support, "*%d %s ", get_id_oggetto(obj), get_nome_oggetto(obj));

					if(get_afferrabile_oggetto(obj) == true) {
						fprintf(file_support, "true");
					} else fprintf(file_support, "false");

					if(get_tipo_oggetto(obj)) {

						if(get_tipo_oggetto(obj) == weapon) {
							fprintf(file_support, " a %d %d", get_danno_arma(obj.oggetto_speciale.weapon), get_durezza_arma(obj.oggetto_speciale.weapon));
						} else if(get_tipo_oggetto(obj) == food) {
							fprintf(file_support, " c %d", get_punti_vita_cibo(obj.oggetto_speciale.food));
						} else if(get_tipo_oggetto(obj) == key) {

							if(get_apertura_apribile(obj.oggetto_speciale.key) == true) {
								fprintf(file_support, " k true ");
							} else {
								fprintf(file_support, " k false ");
							}

							fprintf(file_support, "%d", get_id_chiave_da_usare(obj.oggetto_speciale.key));

						}

					}

					fprintf(file_support, "\n%s", support);

				} else fprintf(file_support, "%s", support); 

				*token = '\0';

			} else fprintf(file_support, "%s", support);
 
		}

	} else printf("Impossibile aprire il file"); 
	fclose(file_storia);
	fclose(file_support);

	remove(pathname_storia);
	rename(pathname_support, pathname_storia);

	return;
}

void remove_enemy_from_file (int pos) {
	char pathname_storia[20] = "storia.txt";
	FILE *file_storia;
	char pathname_support[20] = "storia_support.txt";
	FILE *file_support;

	char support[MAX_CARATT];
	char *token = calloc(10, sizeof(char));

	if((file_storia = fopen(pathname_storia, "r")) != NULL && (file_support = fopen(pathname_support, "w")) != NULL) {

		while(!feof(file_storia)) {

			fgets(support, MAX_CARATT, file_storia);

			if(support[0] == '^') {

				token = scan (support, 1);
				fprintf(file_support, "%s", support);

				if(convert_sequence_char_to_int(token) == pos) {

					while(support[0] != '_') {

						fgets(support, MAX_CARATT, file_storia);

						if(support[0] != '$' && support[0] != '&') {
							fprintf(file_support, "%s", support);
						}

					}

				}

			} else fprintf(file_support, "%s", support);

		}

	} else printf("Impossibile aprire il file");
	
	fclose(file_storia);
	fclose(file_support);

	remove(pathname_storia);
	rename(pathname_support, pathname_storia);

	return;
}

void open_door_from_file(direzione dir, int pos) {
	char pathname_storia[40] = "storia.txt";
	FILE *file_storia;
	char pathname_support[40] = "storia_support.txt";
	FILE *file_support;

	char prelievo[MAX_CARATT];
	char *token = calloc(10, sizeof(char));

	if((file_storia = fopen(pathname_storia, "r")) != NULL && (file_support = fopen(pathname_support, "w")) != NULL) {

		while(!feof(file_storia)) {

			fgets(prelievo, MAX_CARATT, file_storia);

			if(prelievo[0] == '^') {
				token = scan(prelievo, 1);
				fprintf(file_support, "%s", prelievo);

				if(convert_sequence_char_to_int(token) == pos) {

					while(prelievo[0] != '_') {
						fgets(prelievo, MAX_CARATT, file_storia);

						if(prelievo[0] == '%') {
							*token = '\0';
							token = scan(prelievo, 1);
							if(convert_sequence_char_to_int(token) == get_id_destinazione(dir)) {
								fprintf(file_support, "%c%d %c true 0\n", prelievo[0],get_id_destinazione(dir), get_punto_cardinale(dir));
							} else fprintf(file_support, "%s", prelievo);

						} else fprintf(file_support, "%s", prelievo);

					}

				}

				*token = '\0';

			} else fprintf(file_support, "%s", prelievo);

		}

	} else printf("Impossibile aprire il file");
	fclose(file_storia);
	fclose(file_support);

	remove(pathname_storia);
	rename(pathname_support, pathname_storia);

	return;
}

void indovino_indovinello () {

	int number;
	char *answer = calloc(10, sizeof(char));

	direzione dir;
	set_id_destinazione(&dir, 15);
	set_punto_cardinale(&dir, 'n');

	printf("Lì vicino c’è un uomo anziano in ginocchio: pensi che stia pregando ma in realtà ha sentito la tua presenza e sussurra “Sei entrato in un luogo sacro, parla con me.”\n");
	printf("Un plotone di soldati è composto da 3 colonne e 15 righe. Le righe sono distanti tra loro di 2 metri. Quanto è lungo il plotone?\n");

	do {
		printf("Risposta: ");
		fgets(answer, 50, stdin);
		number = convert_sequence_char_to_int(scan(answer, 0));

		if(number == 28) {
			printf("L’uomo si gira, ti guarda e, alzando leggermente la mano, pronuncia qualcosa a te incomprensibile e punta il dito verso la porta a nord del corridoio centrale.\n");
			open_door_from_file(dir, 12);
		} else {
			printf("L'uomo ti ripete la domanda\n");
		}

	} while (number != 28);

}

#include <stdlib.h>
#include "globali.h"
#include "gestione/gestione_personaggio.h"
#include "gestione/gestione_oggetto.h"
#include "gestione_storia.h"
#include "analizzatore_lessicale.h"

void salvataggio_partita(ambiente stanza, personaggio pg) {
	char pathname_storia_corrente[20] = "storia.txt";
	char pathname_storia_salvataggio[40] = "salvataggi/storia_salvataggio.txt";
	char prelievo[MAX_CARATT];
	FILE *file_current, *file_salvataggio;

	//salvataggio storia
	if((file_current = fopen(pathname_storia_corrente, "r")) != NULL && (file_salvataggio = fopen(pathname_storia_salvataggio, "w")) != NULL) {

		while(!feof(file_current)){

			fgets(prelievo, MAX_CARATT, file_current);
			fprintf(file_salvataggio, "%s", prelievo);

		}

	} else printf("Impossibile aprire il file");
	fclose(file_current);
	fclose(file_salvataggio);

	//salvataggio personaggio
	char pathname_personaggio_salvataggio[40] = "salvataggi/personaggio_salvataggio.txt";
	int count = 0;
	if((file_current = fopen(pathname_personaggio_salvataggio, "w")) != NULL) {
		fprintf(file_current, "%d\n", get_posizione_personaggio(pg));
		fprintf(file_current, "%d\n", get_punti_vita_personaggio(pg));

		if(pg.weapon.ID) {
			fprintf(file_current, "&%d %s %d %d\n", get_id_oggetto(get_weapon_personaggio(pg)), get_nome_oggetto(get_weapon_personaggio(pg)), get_danno_arma(get_weapon_personaggio(pg).oggetto_speciale.weapon), get_durezza_arma(get_weapon_personaggio(pg).oggetto_speciale.weapon));
		}

		while(pg.inventario[count].ID != 0 && count < MAX_SLOTS) {
			fprintf(file_current, "%c%d %s ", '*', get_id_oggetto(get_slot_inventario_personaggio(pg, count)), get_nome_oggetto(get_slot_inventario_personaggio(pg, count)));

			if(get_afferrabile_oggetto(get_slot_inventario_personaggio(pg, count)) == true) {
				fprintf(file_current, "%s ", "true");
			} else fprintf(file_current, "%s ", "false");

			if(get_tipo_oggetto(get_slot_inventario_personaggio(pg, count))) {

				if(get_tipo_oggetto(get_slot_inventario_personaggio(pg, count)) == weapon) {
					fprintf(file_current, "%c %d %d", 'a', get_danno_arma(get_slot_inventario_personaggio(pg, count).oggetto_speciale.weapon), get_durezza_arma(get_slot_inventario_personaggio(pg, count).oggetto_speciale.weapon));
				} else if (get_tipo_oggetto(get_slot_inventario_personaggio(pg, count))== food) {
					fprintf(file_current, "%c %d", 'c', get_punti_vita_cibo(get_slot_inventario_personaggio(pg, count).oggetto_speciale.food));
				} else if (get_tipo_oggetto(get_slot_inventario_personaggio(pg, count)) == key) {

					if(get_apertura_apribile(get_slot_inventario_personaggio(pg, count).oggetto_speciale.key) == true) {
						fprintf(file_current, " k true ");
					} else fprintf(file_current, " k false ");

					fprintf(file_current, "%d", get_id_chiave_da_usare(get_slot_inventario_personaggio(pg, count).oggetto_speciale.key));

				}

			}

			fprintf(file_current, "\n");
			count = count + 1;
		}

	} else printf("Impossibile aprire il file");
	fclose(file_current);

	return;
}

void caricare_partita(personaggio * pg) {

	char file_storia_salvataggio[35] = "salvataggi/storia_salvataggio.txt";
	FILE *file_salvataggio;
	char file_storia_caricare[30] = "storia.txt";
	FILE *file_caricare;

	char support[MAX_CARATT];
	//caricamento storia
	if((file_salvataggio = fopen(file_storia_salvataggio, "r")) != NULL && (file_caricare = fopen(file_storia_caricare, "w")) != NULL) {

		while(!(feof(file_salvataggio))) {

			fgets(support, MAX_CARATT, file_salvataggio);
			fprintf(file_caricare, "%s", support);

		}

	} else printf("Impossibile aprire il file");
	fclose(file_caricare);
	fclose(file_salvataggio);

	inizializzazione_inventario(pg);

	char file_dati_pg[40] = "salvataggi/personaggio_salvataggio.txt";
	//caricamento dati pg
	if((file_salvataggio = fopen(file_dati_pg, "r")) != NULL) {
		char *token = calloc(10, sizeof(char));
		int count_inv = 0;

		fgets(support, MAX_CARATT, file_salvataggio);			//prelievo posizione
		token = scan(support, 0);
		set_posizione_personaggio(pg, convert_sequence_char_to_int(token));

		fgets(support, MAX_CARATT, file_salvataggio);			//prelievo punti vita
		token = scan(support, 0);
		set_punti_vita_personaggio(pg, convert_sequence_char_to_int(token));

		while(!feof(file_salvataggio)) {						//prelievo arma + inventario

			int count = 1;
			fgets(support, MAX_CARATT, file_salvataggio);
			oggetto temp;

			if(support[0] == '&') {
				bool id_flag = false, nome_flag = false, danno_flag = false, durezza_flag = false;

				set_afferrabile_oggetto(&temp, true);
				set_tipo_oggetto(&temp, 'a');

				//inizio scansione arma
				while(support[count]) {
					token = scan(support, count);

					if(id_flag == false) {
						set_id_oggetto(&temp, convert_sequence_char_to_int(token));
						id_flag = true;
					} else if(nome_flag == false) {
						set_nome_oggetto(&temp, token);
						nome_flag = true;
					} else if(danno_flag == false) {
						set_danno_arma(&temp.oggetto_speciale.weapon, convert_sequence_char_to_int(token));
						danno_flag = true;
					} else if(durezza_flag == false) {
						set_durezza_arma(&temp.oggetto_speciale.weapon, convert_sequence_char_to_int(token));
						durezza_flag = true;
					}

					if(durezza_flag == true) {
						set_weapon_personaggio(pg, temp);
					}

					int lenght = 0 + strlen(token);
					*token = '\0';
					count = count + 1 + lenght;

				} //fine scansione arma

			} else if(support[0] == '*') {
				bool id_flag = false, nome_flag = false, aff_flag = false, tipo_flag = false, par1_flag = false, par2_flag = false;

				//inizio scansione oggetto trovato
				while(support[count]) {
					token = scan(support, count);

					if(id_flag == false) {

						set_id_oggetto(&temp, convert_sequence_char_to_int(token));
						id_flag = true; 

					} else if(nome_flag == false) {
								
						set_nome_oggetto(&temp, token);
						nome_flag = true;

					} else if(aff_flag == false) {

						if(strcmp(token, "true") == 0) {
							set_afferrabile_oggetto(&temp, true);
						} else {
							set_afferrabile_oggetto(&temp, false);
						}

						aff_flag = true;
					} else if(tipo_flag == false) {

						if(strcmp(token, "a") == 0) {
							set_tipo_oggetto(&temp, weapon);
						} else if(strcmp(token, "c") == 0) {
							set_tipo_oggetto(&temp, food);
						} else if(strcmp(token, "k") == 0) {
							set_tipo_oggetto(&temp, key);
						} 

						tipo_flag = true;
					} else if(par1_flag == false) {
								
						if(get_tipo_oggetto(temp) == weapon) {

							set_danno_arma(&temp.oggetto_speciale.weapon, convert_sequence_char_to_int(token));

						} else if(get_tipo_oggetto(temp) == food) {

							set_punti_vita_cibo(&temp.oggetto_speciale.food, convert_sequence_char_to_int(token));

						} else if(get_tipo_oggetto(temp) == key) {
								
							if(strcmp(token, "true") == 0) {
								set_apertura_apribile(&temp.oggetto_speciale.key, true);
							} else if(strcmp(token, "false") == 0) {
								set_apertura_apribile(&temp.oggetto_speciale.key, false);
							}
									
						}
							
						par1_flag = true;
					}	else if(par2_flag == false) {

						if(get_tipo_oggetto(temp) == weapon) {
							set_durezza_arma(&temp.oggetto_speciale.weapon, convert_sequence_char_to_int(token));
						} else if(get_tipo_oggetto(temp) == key) {
							set_id_chiave_da_usare(&temp.oggetto_speciale.key, convert_sequence_char_to_int(token));
						}

						par2_flag = true;
					}

					if(aff_flag == true) {
						set_slot_inventario_personaggio(pg, count_inv, temp);
					}

					int lenght = 0 + strlen(token);
					*token = '\0';
					count = count + 1 + lenght;
				} // fine scansione oggetto trovato

				count_inv = count_inv + 1;

			}  // fine oggetto trovato
			
			support[0] = '\0';
			set_tipo_oggetto(&temp, 'z');

		}

		descrivere_ambiente(get_posizione_personaggio(*pg));

	} else printf("Impossibile aprire il file");

	return;
}